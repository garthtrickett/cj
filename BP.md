// Apply these wherever possible
1. Use small pure functions 
2. Utilize destructuring 
3. Prefer let bindings over mutable variables
4. Use the power of pattern matching
5. Implement error handling with Result and Option types
6. Take advantage of Rust’s concurrency primitives
7. Prefer composition over inheritance 
8. Apply the Single Responsibility Principle 
9. Apply the Open/Closed Principle (OCP) 
10. Apply the Liskov Substitution Principle (LSP) 
11. Apply the Dependency Inversion Principle (DIP) 
12. Use the .map, .filter and .reduce functions where possible and in combination 
13. Avoid mental mapping 
14. Make Names Searchable 
15. Use default parameters instead of short circuiting or conditionals 
16. Two or fewer function arguments (use destructuring) 
17. Functions should do only one thing 
18. Functions should only be one level of abstraction 
19. Remove duplicate code 
20. Don’t use flags as function parameters 
21. Encapsulate conditionals 
22. Avoid Negative Conditionals 
23. Avoid conditionals by splitting your code up into more, smaller functions 
24. Don’t ignore caught errors 1.
25. Don’t ignore rejected promises 1.
26. Only comment things that have business logic complexity 
27. use enums in place of structs whereever possible

